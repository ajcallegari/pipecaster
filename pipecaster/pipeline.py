import numpy as np
from inspect import signature

import sklearn.base
import pipes

def is_multi_input(pipe):
    """Detect if a pipeline component is multi-input by determining if the first argument to fit() is 'Xs' 
    """
    first_param = list(signature(pipe.fit).parameters.keys())[0]
    return first_param == 'Xs'

def get_clone(pipe, disable_custom_cloning = False):
    
    """Get a new copy of a transformer/estimator/predictor instance. 
    Parameters
    ----------
    pipe : transformer, estimator, predictor
        Pipeline building block
   disable_custom_cloning : bool
        Flag that disables use of the pipe.clone() method
    Returns
    -------
    New transformer/estimator/predictor instance generated by the pipe.clone() method, if there is one. If not, the returned instance is created by the generic sklearn.base.clone() function which basically does: pipe.__class__(**pipe.get_params())
    Notes
    -----
    Cutoming cloning via pipe.clone() has been added in Pipecaster to enable neural net warm starts that don't conform to sklearn's stateless cloning mechanism.
    """
    
    if hasattr(pipe, 'clone') and disable_custom_cloning == False:
        return pipe.clone()
    else:
        return sklearn.base.clone(pipe)
       
class Layer:
    """A list of pipe instances with input mappings that supports construction via slice assignment and broadcasting.
    
    Examples
    --------
    
    """
    
    def __init__(self, n_inputs):
        self.n_inputs = n_inputs
        self.pipe_list = []
        self.all_inputs = set(range(n_inputs))
        self.mapped_inputs = set()
        
    def _get_slice_indices(self, slice_):
        return np.arange(self.n_inputs)[slice_]
        
    def __setitem__(self, slice_, val):
        
        is_listlike = isinstance(val, (list, tuple, np.ndarray))
        
        if type(slice_) == int:
            inputs = [slice_]
        else:
            if slice_.step not in [None, 1]:
                raise ValueError('Invalid slice step; must be exactly 1 (Pipes may only accept contiguous inputs)')
            inputs = self._get_slice_indices(slice_)  
            
        for i in inputs:
            if i not in self.all_inputs:
                raise ValueError('Index out of bounds') 
            if i in self.mapped_inputs:
                raise ValueError('Two pipes may not use the same input (to maintain 1:1 map between inputs and oututs)') 
                
        if is_listlike == False:
            n = len(inputs)
            if is_multi_input(val) == True:
                self.pipe_list.append((get_clone(val), inputs))
            else:
                for i in inputs:
                    self.pipe_list.append((get_clone(val), i))            
        elif is_listlike == True:
            n = len(val)
            if n != len(inputs):
                raise ValueError('Length of array slice is not equal to the length of the assigned list argument')
            else:
                for pipe, i in zip(val, inputs):
                    self.pipe_list.append((get_clone(pipe), i))
            
        self.mapped_inputs = self.mapped_inputs.union(inputs)
        
        return self

class Pipeline:
    
    """Sklearn pipeline modified to accept multuple inputs
    
    """
    
    def __init__(self, n_inputs = 3):
        self.n_inputs = n_inputs
        self.Xs = np.empty(n_inputs, dtype=object)
        self.layers = []
        
    def get_next_layer(self):
        layer = Layer(self.n_inputs)
        self.layers.append(layer)
        return layer
    
    def _fit_layer(self, layer_index, Xs_previous, y, **fit_params):
        layer = self.layers[layer_index]
        for pipe, inputs in layer.pipe_list:
            if hasattr(pipe, 'fit'):
                live_inputs = [i for i in inputs if Xs_previous[i] is not None]
                if len(live_inputs) > 0:
                    pipe.fit(Xs_previous[live_inputs], y, **fit_params)
            else:
                raise TypeError('{} in layer {} is missing a fit() method'.format(pipe.__class__.__name__, i))
        layer.unmapped_inputs_ = layer.all_inputs - layer.mapped_inputs

    def _transform_layer(self, layer_index, Xs_previous):
        layer = self.layers[layer_index]
        Xs_next = np.emtpy(self.n_inputs, dtype=object)
        for pipe, inputs in layer.pipe_list:
            live_inputs = [i for i in inputs if Xs_previous[i] is not None]:
            if len(live_inputs) > 0:
                if hasattr(pipe, 'transform'):
                    Xs_next[live_inputs] = pipe.transform(Xs_previous[live_inputs])                
                elif hasattr(pipe, 'predict_proba'):
                    Xs_next[live_inputs] = pipe.predict_proba(Xs_previous[live_inputs])
                elif hasattr(pipe, 'predict'):
                    pipe.fit(Xs_previous[inputs], y, **fit_params)
                    Xs_next[live_inputs] = pipe.predict(Xs_previous[live_inputs])
                else:
                    raise TypeError('{} in layer {} lacks a method for transforming data'.format(pipe.__class__.__name__, i))        
        # pass the unmapped inputs through with a copy
        for i in layer.unmapped_inputs_:
            Xs_next[i] = None if Xs[i] is None else Xs_previous[i].copy()
        
        return Xs_next
    
    def _predict_layer(self, layer_index, Xs_previous, proba = False):
        layer = self.layers[layer_index]
        Xs_next = np.emtpy(self.n_inputs, dtype=object)
        prediction_indices = []
        for pipe, inputs in layer.pipe_list:
            live_inputs = [i for i in inputs if Xs_previous[i] is not None]:
            if len(live_inputs) > 0:
                if proba == False:
                    if hasattr(pipe, 'transform'):
                        Xs_next[live_inputs] = pipe.transform(Xs_previous[live_inputs])                
                    elif hasattr(pipe, 'predict_proba'):
                        Xs_next[live_inputs] = pipe.predict_proba(Xs_previous[live_inputs])
                    elif hasattr(pipe, 'predict'):
                        pipe.fit(Xs_previous[inputs], y, **fit_params)
                        Xs_next[live_inputs] = pipe.predict(Xs_previous[live_inputs])
                    else:
                        raise TypeError('{} in layer {} lacks a method for transforming data'.format(pipe.__class__.__name__, i))        
        # pass the unmapped inputs through with a copy
        for i in layer.unmapped_inputs_:
            Xs_next[i] = None if Xs[i] is None else Xs_previous[i].copy()
        
        return Xs_next
    
    def fit(self, Xs, y, **fit_params):
        Xs_previous = np.array(Xs, dtype=object)
        for layer in self.layers[:-1]:
            Xs_next = np.emtpy(self.n_inputs, dtype=object)
            for pipe, inputs in layer.pipe_list:
                if hasattr(pipe, 'fit_transform'):
                    Xs_next[inputs] = pipe.fit_transform(Xs_previous[inputs], y, **fit_params)
                elif hasattr(pipe, 'transform'):
                    pipe.fit(Xs_previous[inputs], y, **fit_params)
                    Xs_next[inputs] = pipe.transform(Xs_previous[inputs])                
                elif hasattr(pipe, 'predict_proba'):
                    pipe.fit(Xs_previous[inputs], y, **fit_params)
                    Xs_next[inputs] = pipe.predict_proba(Xs_previous[inputs])
                elif hasattr(pipe, 'predict'):
                    pipe.fit(Xs_previous[inputs], y, **fit_params)
                    Xs_next[inputs] = pipe.predict(Xs_previous[inputs])
            # pass the unmapped inputs through with a copy:
            unmapped_inputs = layer.all_inputs - layer.mapped_input 
            for i in unmapped_inputs:
                Xs_next[i] = None if Xs[i] is None else Xs_previous[i].copy()
            Xs_previous = Xs_next
        # fit the last layer without transoforming:
        for pipe, inputs in self.layers[-1].pipe_list[-1]:
            pipe.fit(Xs_previous[inputs], y, **fit_params)
    
    def fit_transform(self, Xs, y, **fit_params):
        Xs_previous = np.array(Xs, dtype=object)
        for layer in self.layers:
            Xs_next = np.emtpy(self.n_inputs, dtype=object)
            for pipe, inputs in layer.pipe_list:
                if hasattr(pipe, 'fit_transform'):
                    Xs_next[inputs] = pipe.fit_transform(Xs_previous[inputs], y, **fit_params)
                elif hasattr(pipe, 'transform'):
                    pipe.fit(Xs_previous[inputs], y, **fit_params)
                    Xs_next[inputs] = pipe.transform(Xs_previous[inputs])                
                elif hasattr(pipe, 'predict_proba'):
                    pipe.fit(Xs_previous[inputs], y, **fit_params)
                    Xs_next[inputs] = pipe.predict_proba(Xs_previous[inputs])
                elif hasattr(pipe, 'predict'):
                    pipe.fit(Xs_previous[inputs], y, **fit_params)
                    Xs_next[inputs] = pipe.predict(Xs_previous[inputs])
            # pass the unmapped inputs through with a copy
            unmapped_inputs = layer.all_inputs - layer.mapped_input 
            for i in unmapped_inputs:
                Xs_next[i] = None if Xs[i] is None else Xs_previous[i].copy()
            Xs_previous = Xs_next
        
        return Xs_next, y
    
    def predict(self, Xs, y, **fit_params):
        Xs_previous = np.array(Xs, dtype=object)
        for layer in self.layers[:-1]:
            Xs_next = np.emtpy(self.n_inputs, dtype=object)
            for pipe, inputs in layer.pipe_list:
                elif hasattr(pipe, 'transform'):
                    Xs_next[inputs] = pipe.transform(Xs_previous[inputs])                
                elif hasattr(pipe, 'predict_proba'):
                    Xs_next[inputs] = pipe.predict_proba(Xs_previous[inputs])
                elif hasattr(pipe, 'predict'):
                    Xs_next[inputs] = pipe.predict(Xs_previous[inputs])
            # pass the unmapped inputs through with a copy:
            unmapped_inputs = layer.all_inputs - layer.mapped_input 
            for i in unmapped_inputs:
                Xs_next[i] = None if Xs[i] is None else Xs_previous[i].copy()
            Xs_previous = Xs_next
            
        # call predict on the last layer
        Xs_next = np.emtpy(self.n_inputs, dtype=object)
        for pipe, inputs in self.layers[-1].pipe_list:
            if hasattr(pipe, 'predict') == False:
                raise TypeError('Last pipe does not have a predict() method.  Can not predict with this pipeline')
            pipe.predict(Xs_previous[inputs]) 
        unmapped_inputs = layer.all_inputs - layer.mapped_input 
        for i in unmapped_inputs:
            Xs_next[i] = None if Xs[i] is None else Xs_previous[i].copy()
        Xs_previous = Xs_next
            
    def transform(self, Xs, y):
        pass
    
    def predict(Xs):
        # test for presence of predict() method here? not tested during pipeling construction
  
        pass
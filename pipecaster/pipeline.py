import numpy as np
from inspect import signature

import sklearn.base
import pipes

def is_multi_input(pipe):
    """Detect if a pipeline component is multi-input by determining if the first argument to fit() is 'Xs' 
    """
    first_param = list(signature(pipe.fit).parameters.keys())[0]
    return first_param == 'Xs'

def get_clone(pipe, disable_custom_cloning = False):
    
    """Get a new copy of a transformer/estimator/predictor instance. 
    Parameters
    ----------
    pipe : transformer, estimator, predictor
        Pipeline building block
   disable_custom_cloning : bool
        Flag that disables use of the pipe.clone() method
    Returns
    -------
    New transformer/estimator/predictor instance generated by the pipe.clone() method, if there is one. If not, the returned instance is created by the generic sklearn.base.clone() function which basically does: pipe.__class__(**pipe.get_params())
    Notes
    -----
    Cutoming cloning via pipe.clone() has been added in Pipecaster to enable neural net warm starts that don't conform to sklearn's stateless cloning mechanism.
    """
    
    if hasattr(pipe, 'clone') and disable_custom_cloning == False:
        return pipe.clone()
    else:
        return sklearn.base.clone(pipe)
       
class Layer:
    """A list of pipe instances with input mappings to support multi-input transformers. Also supports construction via slice assignment and broadcasting.
    
    Examples
    --------
    
    """
    
    def __init__(self, n_inputs):
        self.n_inputs = n_inputs
        self.pipe_list = []
        self.all_inputs = set(range(n_inputs))
        self.mapped_inputs = set()
        
    def _get_slice_indices(self, slice_):
        return np.arange(self.n_inputs)[slice_]
        
    def __setitem__(self, slice_, val):
        
        is_listlike = isinstance(val, (list, tuple, np.ndarray))
        
        if type(slice_) == int:
            inputs = [slice_]
        else:
            if slice_.step not in [None, 1]:
                raise ValueError('Invalid slice step; must be exactly 1 (Pipes may only accept contiguous inputs)')
            inputs = self._get_slice_indices(slice_)  
            
        for i in inputs:
            if i not in self.all_inputs:
                raise ValueError('Index out of bounds') 
            if i in self.mapped_inputs:
                raise ValueError('Two pipes may not use the same input (to maintain 1:1 map between inputs and outputs)') 
                
        if is_listlike == False:
            n = len(inputs)
            if is_multi_input(val) == True:
                self.pipe_list.append((get_clone(val), inputs))
            else:
                for i in inputs:
                    self.pipe_list.append((get_clone(val), i))            
        elif is_listlike == True:
            n = len(val)
            if n != len(inputs):
                raise ValueError('Length of array slice is not equal to the length of the assigned list argument')
            else:
                for pipe, i in zip(val, inputs):
                    self.pipe_list.append((get_clone(pipe), i))
            
        self.mapped_inputs = self.mapped_inputs.union(inputs)
        
        return self
        
    def get_pipe_from_input(self, input_index):
        for pipe, inputs in layer.pipe_list:
            if type(inputs) == int and inputs == input_index:
                return pipe
            elif input_index in inputs:
                return pipe
        return None

class Pipeline:
    
    """Sklearn pipeline modified to accept multiple inputs.
    
    """
    
    def __init__(self, n_inputs = 3):
        self.n_inputs = n_inputs
        self.layers = []
        
    def get_next_layer(self):
        layer = Layer(self.n_inputs)
        self.layers.append(layer)
        return layer
    
    def _get_live_inputs(inputs, Xs):
        if type(inputs) == int:
            live_inputs = [] if Xs[inputs] is None else inputs
        else:
            live_inputs = [i for i in inputs if Xs[i] is not None]    
            
    def _fit_layer(self, layer_index, Xs, y, **fit_params):
        layer = self.layers[layer_index]
        for pipe, inputs in layer.pipe_list:
            if hasattr(pipe, 'fit'):
                live_inputs = self._get_live_inputs(inputs, Xs)
                if type(live_inputs) == int or len(live_inputs) > 0:
                    pipe.fit(Xs[live_inputs], y, **fit_params)
            else:
                raise TypeError('{} in layer {} is missing a fit() method'.format(pipe.__class__.__name__, layer_index))
        layer.unmapped_inputs_ = layer.all_inputs - layer.mapped_inputs

    def _transform_layer(self, layer_index, Xs):
        layer = self.layers[layer_index]
        Xs_t = np.emtpy(self.n_inputs, dtype=object)
        for pipe, inputs in layer.pipe_list:
            live_inputs = self._get_live_inputs(inputs, Xs)
            if type(live_inputs) == int or len(live_inputs) > 0:
                if hasattr(pipe, 'transform'):
                    Xs_t[live_inputs] = pipe.transform(Xs[live_inputs])                
                elif hasattr(pipe, 'predict_proba'):
                    Xs_t[live_inputs] = pipe.predict_proba(Xs[live_inputs])
                elif hasattr(pipe, 'predict'):
                    Xs_t[live_inputs] = pipe.predict(Xs[live_inputs])
                else:
                    raise TypeError('{} in layer {} lacks a method for transforming data'
                                    .format(pipe.__class__.__name__, layer_index))        
        # pass the unmapped inputs through
        Xs_t[layer.unmapped_inputs_] = Xs[layer.unmapped_inputs_]
        
        return Xs_t
    
    def _predict_layer(self, layer_index, Xs, proba = False):
        layer = self.layers[layer_index]
        predictions = np.emtpy(self.n_inputs, dtype=object)
        for pipe, inputs in layer.pipe_list:
            live_inputs = self._get_live_inputs(inputs, Xs)
            if type(live_inputs) == int or len(live_inputs) > 0:
                if proba == True:
                    if hasattr(pipe, 'predict_proba'):
                        predictions[live_inputs] = pipe.predict_proba(Xs[live_inputs])
                    else: 
                        raise TypeError('{} in layer {} lacks a required predict_proba() method'
                                        .format(pipe.__class__.__name__, layer_index)) 
                else:
                    if hasattr(pipe, 'predict'):
                        predictions[live_inputs] = pipe.predict(Xs[live_inputs])
                    else:
                        raise TypeError('{} in layer {} lacks a method for making predictions'
                                        .format(pipe.__class__.__name__, layer_index))        
        # set all unmapped inputs to None
        predictions[layer.unmapped_inputs_] = None
            
        outputs = [predictions[i] for i in range(self.n_inputs) if predictions[i] is not None]
                
        if len(outputs) == 1:
            # typical pattern: pipeline has converged to a single y
            return outputs[0]
        else:
            # atypical pattern: pipeline has not converged and final layer makes multiple predictions
            return predictions
        
    def fit(self, Xs, y, **fit_params):
        Xs = np.array(Xs, dtype=object)
        n_layers = len(self.layers)
        for i in range(n_layers - 1):
            self._fit_layer(i, Xs, y, **fit_params)
            Xs = self._transform_layer(i, Xs)
        # fit the last layer without transforming:
        self._fit_layer(n_layers, Xs, y, **fit_params)
    
    def transform(self, Xs):
        Xs = np.array(Xs, dtype=object)
        n_layers = len(self.layers)
        for i in range(n_layers):
            Xs = self._transform_layer(i, Xs)
        return Xs
    
    def predict(self, Xs):
        Xs = np.array(Xs, dtype=object)
        n_layers = len(self.layers)
        for i in range(n_layers - 1):
            Xs = self._transform_layer(i, Xs)
        return self._predict_layer(n_layers, Xs)
    
    def predict_proba(self, Xs):
        Xs = np.array(Xs, dtype=object)
        n_layers = len(self.layers)
        for i in range(n_layers - 1):
            Xs = self._transform_layer(i, Xs)
        return self._predict_layer(n_layers, Xs, proba = True)
    
    def get_pipe(self, input_index, layer_index):
        return self.layers[layer_index].get_pipe_from_input(input_index)
    
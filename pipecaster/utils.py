from inspect import signature, getfullargspec
import sklearn.base
import joblib

__all__ = ['is_classifier', 'is_regressor', 'detect_estimator_type', 'is_multi_input', 'get_clone', 'get_list_clone', 
           'save_model', 'load_model', 'get_transform_method', 'get_predict_method', 'is_predictor', 'FitError', 
           'get_descriptor', 'get_param_names']

def is_classifier(obj):
    if hasattr(obj, '_estimator_type'):
        if getattr(obj, '_estimator_type', None) == 'classifier':
            return True
    elif hasattr(obj, 'classes_'):
        return True
    else:
        return False
     
def is_regressor(obj):
    if hasattr(obj, '_estimator_type'):
        if getattr(obj, '_estimator_type', None) == 'regressor':
            return True
    elif hasattr(obj, 'classes_'):
        return False
    else:
        return False
    
def detect_estimator_type(obj):
    if is_classifier(obj):
        _estimator_type = 'classifier'
    elif is_regressor(obj):
        _estimator_type = 'regressor'
    else:
        _estimator_type = 'unknown'
    return _estimator_type

def is_multi_input(pipe):
    """Detect if a pipeline component is multi-input by determining if the first argument to fit() is 'Xs' 
    """
    first_param = list(signature(pipe.fit).parameters.keys())[0]
    return first_param == 'Xs'

def get_clone(pipe, disable_custom_cloning = False):
    
    """Get a new copy of a transformer/estimator/predictor instance. 
    Parameters
    ----------
    pipe : transformer, estimator, predictor
        Pipeline building block
    disable_custom_cloning : bool
        Flag that disables use of the pipe.get_clone() method
    Returns
    -------
    New transformer/estimator/predictor instance generated by the pipe.get_clone() method, if there is one. If not, the returned instance is created by the generic sklearn.base.clone() function which basically does: pipe.__class__(**pipe.get_params())
    Notes
    -----
    Cutoming cloning via pipe.get_clone() has been added in Pipecaster to enable neural net warm starts that don't conform to sklearn's stateless cloning mechanism.
    """
    
    if hasattr(pipe, 'get_clone') and disable_custom_cloning == False:
        return pipe.get_clone()
    else:
        return sklearn.base.clone(pipe)
    
def get_list_clone(pipes):
    if isinstance(pipes, (list, tuple, np.ndarray)):
        return get_clone(pipes)
    else:
        return [get_clone(p) if p is not None else None for p in pipes]
    
def save_model(model, filepath):
    joblib.dump(model, filepath) 
    
def load_model(filepath):
    return joblib.load(filepath) 
    
def get_transform_method(pipe):
    if hasattr(pipe, 'transform'):
        transform_method = getattr(pipe, 'transform')
    elif hasattr(pipe, 'predict_proba'):
        transform_method = getattr(pipe, 'predict_proba')
    elif hasattr(pipe, 'decision_function'):
        transform_method = getattr(pipe, 'decision_function')
    elif hasattr(pipe, 'predict'):
        transform_method = getattr(pipe, 'predict')
    else:
        transform_method = None
            
    return transform_method

def get_predict_method(pipe):
    if hasattr(pipe, 'predict'):
        predict_method = getattr(pipe, 'predict')
    elif hasattr(pipe, 'predict_proba'):
        predict_method = getattr(pipe, 'predict_proba')
    elif hasattr(pipe, 'decision_function'):
        predict_method = getattr(pipe, 'decision_function')
    else:
        predict_method = None
            
    return predict_method

def is_predictor(pipe):
    return False if get_predict_method(pipe) is None else True

class FitError(Exception):
    """Exception raised when calls to fit() fail
    """
    def __init__(self, message="call to fit() method failed"):
        self.message = message
        super().__init__(self.message)
        
def get_descriptor(class_name, params, verbose = True):
        string_ = class_name + '('
        
        if verbose:
            argstrings = []
            for k, v in params.items():
                argstring = k + '=' 
                if hasattr(v, '__name__'):
                    argstring += v.__name__
                elif hasattr(v, '__str__'):
                    argstring += v.__str__()
                elif type(v) in [str, int, float]:
                    argstring += v
                else:
                    argstring += 'NA'
                argstrings.append(argstring)
            string_ += ', '.join(argstrings)
                    
        return  string_ + ')'
    
def get_param_names(callable_, omit_self = True):
    param_names = set(getfullargspec(callable_)[0])
    if omit_self:
        param_names.remove('self')
    return param_names

def get_param_clone(pipe):
    return pipe.__class__(**pipe.get_params())

class Parameterized:
    
    state_variables = ['override me with a list of state attributes to set on calls to get_clone']
    
    def __init__(self, **params):
        self._init_params(locals())
        
    @property
    def param_names(self):
        return get_param_names(self.__init__)
                
    def _init_params(self, locals_):
        for param_name in self.param_names:
            setattr(self, param_name, locals_[param_name])
    
    def __str__(self, verbose=True):
        return get_descriptor(self.__class__.__name__, self.get_params(), verbose)
    
    def __repr__(self):
        return self.__str__(verbose=True)  
    
    def get_params(self, deep=False):
        return {p:getattr(self,p) for p in self.param_names}
    
    def set_params(self, params):
        for key, value in params.items():
            if key in self.__class__.params:
                setattr(self, key, value)
            else:
                raise AttributeError('invalid parameter name')
    
    def get_clone(self):
        clone = get_param_clone(self)
        for var in self.__class__.state_variables:
            if hasattr(self, var):
                setattr(clone, var, getattr(self, var))
        return clone
    
class Saveable:
    
    def save(self, filepath):
        joblib.dump(self, filepath)
        
    @staticmethod
    def load(filepath):
        return joblib.load(filepath) 
from inspect import signature, getfullargspec
import sklearn.base
import joblib

__all__ = ['is_classifier', 'is_regressor', 'detect_estimator_type', 'is_multi_input', 'get_clone', 'get_list_clone', 
           'save_model', 'load_model', 'get_transform_method', 'get_predict_method', 'is_predictor', 'FitError', 
           'get_descriptor', 'get_param_names']

def is_classifier(obj):
    if hasattr(obj, '_estimator_type'):
        if getattr(obj, '_estimator_type', None) == 'classifier':
            return True
    elif hasattr(obj, 'classes_'):
        return True
    else:
        return False
     
def is_regressor(obj):
    if hasattr(obj, '_estimator_type'):
        if getattr(obj, '_estimator_type', None) == 'regressor':
            return True
    elif hasattr(obj, 'classes_'):
        return False
    else:
        return False
    
def detect_estimator_type(obj):
    if is_classifier(obj):
        _estimator_type = 'classifier'
    elif is_regressor(obj):
        _estimator_type = 'regressor'
    else:
        _estimator_type = 'unknown'
    return _estimator_type

def is_multi_input(pipe):
    """Detect if a pipeline component is multi-input by determining if the first argument to fit() is 'Xs' 
    """
    first_param = list(signature(pipe.fit).parameters.keys())[0]
    return first_param == 'Xs'

def get_clone(pipe, disable_custom_cloning = False):
    
    """Get a new copy of a transformer/estimator/predictor instance. 
    Parameters
    ----------
    pipe : transformer, estimator, predictor
        Pipeline building block
    disable_custom_cloning : bool
        Flag that disables use of the pipe.get_clone() method
    Returns
    -------
    New transformer/estimator/predictor instance generated by the pipe.get_clone() method, if there is one. If not, the returned instance is created by the generic sklearn.base.clone() function which basically does: pipe.__class__(**pipe.get_params())
    Notes
    -----
    Cutoming cloning via pipe.get_clone() has been added in Pipecaster to enable neural net warm starts that don't conform to sklearn's stateless cloning mechanism.
    """
    
    if hasattr(pipe, 'get_clone') and disable_custom_cloning == False:
        return pipe.get_clone()
    else:
        return sklearn.base.clone(pipe)
    
def get_list_clone(pipes):
    if isinstance(pipes, (list, tuple, np.ndarray)):
        return get_clone(pipes)
    else:
        return [get_clone(p) if p is not None else None for p in pipes]
    
def save_model(model, filepath):
    joblib.dump(model, filepath) 
    
def load_model(filepath):
    return joblib.load(filepath) 
    
def get_transform_method(pipe):
    if hasattr(pipe, 'transform'):
        transform_method = getattr(pipe, 'transform')
    elif hasattr(pipe, 'predict_proba'):
        transform_method = getattr(pipe, 'predict_proba')
    elif hasattr(pipe, 'decision_function'):
        transform_method = getattr(pipe, 'decision_function')
    elif hasattr(pipe, 'predict'):
        transform_method = getattr(pipe, 'predict')
    else:
        transform_method = None
            
    return transform_method

def get_predict_method(pipe):
    if hasattr(pipe, 'predict'):
        predict_method = getattr(pipe, 'predict')
    elif hasattr(pipe, 'predict_proba'):
        predict_method = getattr(pipe, 'predict_proba')
    elif hasattr(pipe, 'decision_function'):
        predict_method = getattr(pipe, 'decision_function')
    else:
        predict_method = None
            
    return predict_method

def is_predictor(pipe):
    return False if get_predict_method(pipe) is None else True

class FitError(Exception):
    """Exception raised when calls to fit() fail
    """
    def __init__(self, message="call to fit() method failed"):
        self.message = message
        super().__init__(self.message)
        
def get_descriptor(class_name, params, verbose = True):
        string_ = class_name + '('
        
        if verbose:
            argstrings = []
            for k, v in params.items():
                argstring = k + '=' 
                if hasattr(v, '__name__'):
                    argstring += v.__name__
                elif hasattr(v, '__str__'):
                    argstring += v.__str__()
                elif type(v) in [str, int, float]:
                    argstring += v
                else:
                    argstring += 'NA'
                argstrings.append(argstring)
            string_ += ', '.join(argstrings)
                    
        return  string_ + ')'
    
def get_param_names(callable_, omit_self = True):
    param_names = set(getfullargspec(Foobar.__init__)[0])
    if omit_self:
        param_names.remove('self')
    return param_names